{"Id": "47536542", "PostTypeId": "1", "CreationDate": "2017-11-28T16:34:52.080", "Score": "3", "ViewCount": "5309", "Body": "<p>I'm encountering some problems using Serverless framework, since i accidentally used the same name of a service on another one. </p>\n\n<p><code>An error occurred: tableX - TableX already exists.</code></p>\n\n<p>Let's suppose that i have two \"<strong>serverless.yml</strong>\" files, both with the same name of service. One of them (let's call it, \"<strong>test1</strong>\") have resources (DynamoDB tables), the other hasn't (\"<strong>test2</strong>\"). Like the following snippets:</p>\n\n<p>Test1</p>\n\n<pre><code>service: sandbox-core\nprovider:\n  name: aws\n  stage: core\n  runtime: nodejs6.10\n  region: sa-east-1\n  memorySize: 128\n  timeout: 300\n\nresources:\n  Resources:\n\n    table3:\n      Type: 'AWS::DynamoDB::Table'\n      DeletionPolicy: Retain\n      Properties:\n        TableName: SandboxTable3\n        AttributeDefinitions:\n          -\n            AttributeName: provider\n            AttributeType: S\n          -\n            AttributeName: appId\n            AttributeType: S\n        KeySchema:\n          -\n            AttributeName: provider\n            KeyType: HASH\n          -\n            AttributeName: appId\n            KeyType: RANGE\n\n        ProvisionedThroughput:\n          ReadCapacityUnits: 1\n          WriteCapacityUnits: 1\n\n    table4:\n      Type: 'AWS::DynamoDB::Table'\n      DeletionPolicy: Retain\n      Properties:\n        TableName: SandboxTable4\n        AttributeDefinitions:\n          -\n            AttributeName: session\n            AttributeType: S\n        KeySchema:\n          -\n            AttributeName: session\n            KeyType: HASH\n\n        ProvisionedThroughput:\n          ReadCapacityUnits: 5\n          WriteCapacityUnits: 1\n\nfunctions:\n  auth:\n    handler: handler.auth\n    events:\n      - http:\n          path: auth/{session}/{provider}/{appId}\n          method: get\n          cors: true\n</code></pre>\n\n<p>Test2</p>\n\n<pre><code>service: sandbox-core\n\nprovider:\n  name: aws\n  stage: core\n  runtime: nodejs6.10\n  region: sa-east-1\n  memorySize: 128\n  timeout: 300\n\nfunctions:\n  createCustomData:\n    handler: handler.createCustomData\n    events:\n      - http:\n          path: teste2\n          method: post\n          cors: true\n</code></pre>\n\n<p>When i <code>sls deploy</code> the \"<strong>test1</strong>\", he creates the tables as i wanted, with <code>DeletionPolicy: Retain</code>, for the tables with very sensible data. Then i <code>sls deploy</code> \"<strong>test2</strong>\" that has other functions but doesn't have any resources (DynamoDB tables), he does what is expected: skip the deletion of the tables. </p>\n\n<p>But, when i sls deploy \"<strong>test1</strong>\" again, he doesn't recognizes the tables, he starts to \"create\" existing tables rather than update them, and fails to deploy.</p>\n\n<p>I need the tables that aren't deleted, and need the functions on the service. It looks like the Cloud Formation losted the track of the created tables from the first deploy.</p>\n\n<p>I don't whant to separate the services (one only for the resources) like was said on this <a href=\"https://github.com/serverless/serverless/issues/3183\" rel=\"nofollow noreferrer\">github thread</a>.\nI need the tables that are running, it has a lot of data and it's too much expensive to backup and restore it to another one, a lot of users could be affected.</p>\n\n<p>So, how do i tell to Cloud Formation Stack that i'm updating that table, and not trying to create it? How to keep track of a service on the Cloud Formation Stack? And, how do i prevent to deploy a service with resources without them? </p>\n\n<p>What's the best solution for this case? Hope that my questions are clear enough to understand. </p>\n", "OwnerUserId": "8548278", "LastActivityDate": "2021-06-30T19:55:04.477", "Title": "Serverless Service update Dynamodb table created with DeletionPolicy retain", "Tags": "|amazon-web-services|amazon-dynamodb|aws-cloudformation|serverless-framework|serverless|", "AnswerCount": "3", "CommentCount": "0", "ContentLicense": "CC BY-SA 3.0", "history": [{"Id": "161625119", "PostHistoryTypeId": "2", "PostId": "47536542", "RevisionGUID": "ce7011f8-75bf-4298-8fbd-8495863e663f", "CreationDate": "2017-11-28T16:34:52.080", "UserId": "8548278", "Text": "I'm encountering some problems using Serverless framework, since i accidentally used the same name of a service on another one. \r\n\r\n`An error occurred: tableX - TableX already exists.`\r\n\r\nLet's suppose that i have two \"**serverless.yml**\" files, both with the same name of service. One of them (let's call it, \"**test1**\") have resources (DynamoDB tables), the other hasn't (\"**test2**\"). Like the following snippets:\r\n\r\nTest1\r\n\r\n    service: sandbox-core\r\n    provider:\r\n      name: aws\r\n      stage: core\r\n      runtime: nodejs6.10\r\n      region: sa-east-1\r\n      memorySize: 128\r\n      timeout: 300\r\n    \r\n    resources:\r\n      Resources:\r\n        \r\n        table3:\r\n          Type: 'AWS::DynamoDB::Table'\r\n          DeletionPolicy: Retain\r\n          Properties:\r\n            TableName: SandboxTable3\r\n            AttributeDefinitions:\r\n              -\r\n                AttributeName: provider\r\n                AttributeType: S\r\n              -\r\n                AttributeName: appId\r\n                AttributeType: S\r\n            KeySchema:\r\n              -\r\n                AttributeName: provider\r\n                KeyType: HASH\r\n              -\r\n                AttributeName: appId\r\n                KeyType: RANGE\r\n              \r\n            ProvisionedThroughput:\r\n              ReadCapacityUnits: 1\r\n              WriteCapacityUnits: 1\r\n    \r\n        table4:\r\n          Type: 'AWS::DynamoDB::Table'\r\n          DeletionPolicy: Retain\r\n          Properties:\r\n            TableName: SandboxTable4\r\n            AttributeDefinitions:\r\n              -\r\n                AttributeName: session\r\n                AttributeType: S\r\n            KeySchema:\r\n              -\r\n                AttributeName: session\r\n                KeyType: HASH\r\n    \r\n            ProvisionedThroughput:\r\n              ReadCapacityUnits: 5\r\n              WriteCapacityUnits: 1\r\n    \r\n    functions:\r\n      auth:\r\n        handler: handler.auth\r\n        events:\r\n          - http:\r\n              path: auth/{session}/{provider}/{appId}\r\n              method: get\r\n              cors: true\r\n\r\nTest2\r\n\r\n    service: sandbox-core\r\n    \r\n    provider:\r\n      name: aws\r\n      stage: core\r\n      runtime: nodejs6.10\r\n      region: sa-east-1\r\n      memorySize: 128\r\n      timeout: 300\r\n    \r\n    functions:\r\n      createCustomData:\r\n        handler: handler.createCustomData\r\n        events:\r\n          - http:\r\n              path: teste2\r\n              method: post\r\n              cors: true\r\n\r\nWhen i `sls deploy` the \"**test1**\", he creates the tables as i wanted, with `DeletionPolicy: Retain`, for the tables with very sensible data. Then i `sls deploy` \"**test2**\" that has other functions but doesn't have any resources (DynamoDB tables), he does what is expected: skip the deletion of the tables. \r\n\r\nBut, when i sls deploy \"**test1**\" again, he doesn't recognizes the tables, he starts to \"create\" existing tables rather than update them, and fails to deploy.\r\n\r\nI need the tables that aren't deleted, and need the functions on the service. It looks like the Cloud Formation losted the track of the created tables from the first deploy.\r\n\r\nI don't whant to separate the services (one only for the resources) like was said on this [github thread][1].\r\nI need the tables that are running, it has a lot of data and it's too much expensive to backup and restore it to another one, a lot of users could be affected.\r\n\r\nSo, how do i tell to Cloud Formation Stack that i'm updating that table, and not trying to create it? How to keep track of a service on the Cloud Formation Stack? And, how do i prevent to deploy a service with resources without them? \r\n\r\nWhat's the best solution for this case? Hope that my questions are clear enough to understand. \r\n\r\n\r\n  [1]: https://github.com/serverless/serverless/issues/3183", "ContentLicense": "CC BY-SA 3.0", "filtered-sentences": [{"source": "Text", "text": "One of them (let's call it, \"**test1**\") have resources (DynamoDB tables), the other hasn't (\"**test2**\"). ", "keywords": ["test"]}, {"source": "Text", "text": "Like the following snippets: Test1 service: sandbox-core provider: name: aws stage: core runtime: nodejs6.10 region: sa-east-1 memorySize: 128 timeout: 300 resources: Resources: table3: Type: 'AWS::DynamoDB::Table' DeletionPolicy: Retain Properties: TableName: SandboxTable3 AttributeDefinitions: - AttributeName: provider AttributeType: S - AttributeName: appId AttributeType: S KeySchema: - AttributeName: provider KeyType: HASH - AttributeName: appId KeyType: RANGE ProvisionedThroughput: ReadCapacityUnits: 1 WriteCapacityUnits: 1 table4: Type: 'AWS::DynamoDB::Table' DeletionPolicy: Retain Properties: TableName: SandboxTable4 AttributeDefinitions: - AttributeName: session AttributeType: S KeySchema: - AttributeName: session KeyType: HASH ProvisionedThroughput: ReadCapacityUnits: 5 WriteCapacityUnits: 1 functions: auth: handler: handler.auth events: - http: path: auth/{session}/{provider}/{appId} method: get cors: true Test2 service: sandbox-core provider: name: aws stage: core runtime: nodejs6.10 region: sa-east-1 memorySize: 128 timeout: 300 functions: createCustomData: handler: handler.createCustomData events: - http: path: teste2 method: post cors: true When i `sls deploy` the \"**test1**\", he creates the tables as i wanted, with `DeletionPolicy: Retain`, for the tables with very sensible data. ", "keywords": ["provider", "test"]}, {"source": "Text", "text": "Then i `sls deploy` \"**test2**\" that has other functions but doesn't have any resources (DynamoDB tables), he does what is expected: skip the deletion of the tables. ", "keywords": ["test"]}, {"source": "Text", "text": "But, when i sls deploy \"**test1**\" again, he doesn't recognizes the tables, he starts to \"create\" existing tables rather than update them, and fails to deploy. ", "keywords": ["test"]}, {"source": "Text", "text": "I need the tables that are running, it has a lot of data and it's too much expensive to backup and restore it to another one, a lot of users could be affected. ", "keywords": ["expense"]}]}, {"Id": "161625120", "PostHistoryTypeId": "1", "PostId": "47536542", "RevisionGUID": "ce7011f8-75bf-4298-8fbd-8495863e663f", "CreationDate": "2017-11-28T16:34:52.080", "UserId": "8548278", "Text": "Serverless Service update Dynamodb table created with DeletionPolicy retain", "ContentLicense": "CC BY-SA 3.0", "filtered-sentences": []}, {"Id": "161625121", "PostHistoryTypeId": "3", "PostId": "47536542", "RevisionGUID": "ce7011f8-75bf-4298-8fbd-8495863e663f", "CreationDate": "2017-11-28T16:34:52.080", "UserId": "8548278", "Text": "|amazon-web-services|amazon-dynamodb|aws-cloudformation|serverless-framework|serverless|", "ContentLicense": "CC BY-SA 3.0", "filtered-sentences": []}], "answers": [{"Id": "68200888", "PostTypeId": "2", "ParentId": "47536542", "CreationDate": "2021-06-30T19:55:04.477", "Score": "0", "Body": "<p><strong>The proper way to fix cloudformation + dynamodb retained tables:</strong>\nYou can import already existing resources in <code>AWS/cloudformation/stacks/my-stack</code>:</p>\n<ol>\n<li><p>Copy the Template that you have deployed in the stack (Template tab)</p>\n</li>\n<li><p>run <code>sls package</code> with args (<code>--stage $stage</code> etc) so you can get the generated .serverless/cloudformation_template_update_stack.json for your master version of the project</p>\n</li>\n<li><p>find the missing resources &quot;already existing&quot; (easy way, filter events with DELETE_SKIPPED)\n<a href=\"https://i.stack.imgur.com/VCFZW.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/VCFZW.png\" alt=\"RETAINED DATABASE RESOURCES\" /></a></p>\n</li>\n<li><p>Copy the resources from .serverless/cloudformation_template_update_stack.json to the Template found in point <strong>1</strong></p>\n</li>\n<li><p>Stack Actions &gt;&gt; import resources in to stack</p>\n</li>\n<li><p>Upload template file / add the table names in the gaps (they are just in the resources themselves)</p>\n</li>\n<li><p>Validate that the actions to do are just importing the missing tables to the stack and press enter\n<a href=\"https://i.stack.imgur.com/SguFh.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/SguFh.png\" alt=\"import resource validation actions\" /></a></p>\n</li>\n<li><p>See that the Events with the imports\n<a href=\"https://i.stack.imgur.com/G0k1b.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/G0k1b.png\" alt=\"import resource events\" /></a></p>\n</li>\n</ol>\n", "OwnerUserId": "4557368", "LastActivityDate": "2021-06-30T19:55:04.477", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "249441394", "PostHistoryTypeId": "2", "PostId": "68200888", "RevisionGUID": "8cc3a018-7577-41f9-b1ec-ff7023e7f9e7", "CreationDate": "2021-06-30T19:55:04.477", "UserId": "4557368", "Text": "**The proper way to fix cloudformation + dynamodb retained tables:** \r\nYou can import already existing resources in `AWS/cloudformation/stacks/my-stack`:\r\n\r\n 1. Copy the Template that you have deployed in the stack (Template tab)\r\n 2. run `sls package` with args (`--stage $stage` etc) so you can get the generated .serverless/cloudformation_template_update_stack.json for your master version of the project\r\n 3. find the missing resources \"already existing\" (easy way, filter events with DELETE_SKIPPED)\r\n[![RETAINED DATABASE RESOURCES][1]][1]\r\n\r\n\r\n 4. Copy the resources from .serverless/cloudformation_template_update_stack.json to the Template found in point **1**\r\n 5. Stack Actions >> import resources in to stack\r\n 6. Upload template file / add the table names in the gaps (they are just in the resources themselves)\r\n 7. Validate that the actions to do are just importing the missing tables to the stack and press enter\r\n[![import resource validation actions][2]][2]\r\n 8. See that the Events with the imports\r\n[![import resource events][3]][3]\r\n\r\n\r\n  [1]: https://i.stack.imgur.com/VCFZW.png\r\n  [2]: https://i.stack.imgur.com/SguFh.png\r\n  [3]: https://i.stack.imgur.com/G0k1b.png", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "filtered-sentences": []}, {"Id": "47539611", "PostTypeId": "2", "ParentId": "47536542", "CreationDate": "2017-11-28T19:39:10.783", "Score": "7", "Body": "<p>There is no problem related to <code>test2</code>. </p>\n\n<p>For <code>test1</code>, you are fine to <code>sls deploy</code> many times.</p>\n\n<p>But if you run <code>sls remove</code>, when the dynamodb is set to  <code>Retain</code>  in <code>serverless.yml</code>, the dynamodb table isn't deleted. So you can't create it again with <code>sls deploy</code>, because the resource with same name is exist. This is the design in aws cloudformation. </p>\n\n<p>You found the open ticket already for a new feature to skip resources. We have to wait for the feature to be developed and merged. I am waiting for the same solution as well. Go there to vote it up!</p>\n\n<p>With current situation, you have to backup the dynamodb, destroy it, and run <code>sls deploy</code>, and restore it if it is really matter.</p>\n\n<p>I normally manage with variable, such as </p>\n\n<pre><code>DeletionPolicy: ${self:custom.${self:custom.stage}.deletion_policy}\n</code></pre>\n\n<p>in custom for different environments:</p>\n\n<pre><code>custom\n  dev:\n    deletion_policy: Delete\n  prod:\n    deletion_policy: Retain\n</code></pre>\n", "OwnerUserId": "498256", "LastEditorUserId": "498256", "LastEditDate": "2019-05-28T02:46:04.717", "LastActivityDate": "2019-05-28T02:46:04.717", "CommentCount": "1", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "82055727", "PostId": "47539611", "Score": "0", "Text": "But i don't want to create it again, i want to update the tables and the functions. When i sls deploy the \"test2\", \"test1\" doesn't exists anymore, when i try to sls deploy \"test1\" again i just can't do it, because the \"tables already exist\". Try the codes i've put here, to see what happens.", "CreationDate": "2017-11-29T09:44:52.863", "UserId": "8548278", "filtered-sentences": [{"source": "Text", "text": "When i sls deploy the \"test2\", \"test1\" doesn't exists anymore, when i try to sls deploy \"test1\" again i just can't do it, because the \"tables already exist\". ", "keywords": ["test"]}]}], "history": [{"Id": "161637704", "PostHistoryTypeId": "2", "PostId": "47539611", "RevisionGUID": "96f3337a-2caf-4102-9546-be4500e8c10b", "CreationDate": "2017-11-28T19:39:10.783", "UserId": "498256", "Text": "There is no problem related to `test2`. \r\n\r\nFor `test1`, you are fine to `sls deploy` many times, it should update for you. \r\n\r\nBut if you do `sls remove` before, when the dynamodb is set to  `Retain`  in `serverless.yml`, you can't create it again with `sls deploy`. This is the design in aws cloudformation. \r\n\r\nYou found the open ticket already for a new feature to skip resources. We have to wait for the feature to be developed and merged. I am waiting for the same solution as well. Go there to vote it up!\r\n\r\nWith current situation, you have to backup the dynamodb, destroy it, and run `sls deploy`, and restore it if it is really matter.\r\n\r\nI normally manage with variable, such as `DeletionPolicy: ${self:custom.deletion_policy}` in custom for different environments:\r\n\r\n    custom\r\n      dev:\r\n        deletion_policy: Delete\r\n      prod:\r\n        deletion_policy: Retain\r\n", "ContentLicense": "CC BY-SA 3.0", "filtered-sentences": [{"source": "Text", "text": "There is no problem related to `test2`. ", "keywords": ["test"]}, {"source": "Text", "text": "For `test1`, you are fine to `sls deploy` many times, it should update for you. ", "keywords": ["test"]}, {"source": "Text", "text": "You found the open ticket already for a new feature to skip resources. ", "keywords": ["feature"]}, {"source": "Text", "text": "We have to wait for the feature to be developed and merged. ", "keywords": ["feature"]}]}, {"Id": "161638093", "PostHistoryTypeId": "5", "PostId": "47539611", "RevisionGUID": "ecd3b9eb-7dde-433f-b9b6-b84f307cfc79", "CreationDate": "2017-11-28T19:44:29.343", "UserId": "498256", "Comment": "added 21 characters in body", "Text": "There is no problem related to `test2`. \r\n\r\nFor `test1`, you are fine to `sls deploy` many times, it should update for you. \r\n\r\nBut if you do `sls remove` before, when the dynamodb is set to  `Retain`  in `serverless.yml`, you can't create it again with `sls deploy`. This is the design in aws cloudformation. \r\n\r\nYou found the open ticket already for a new feature to skip resources. We have to wait for the feature to be developed and merged. I am waiting for the same solution as well. Go there to vote it up!\r\n\r\nWith current situation, you have to backup the dynamodb, destroy it, and run `sls deploy`, and restore it if it is really matter.\r\n\r\nI normally manage with variable, such as `DeletionPolicy: ${self:custom.${self:custom.stage}.deletion_policy}` in custom for different environments:\r\n\r\n    custom\r\n      dev:\r\n        deletion_policy: Delete\r\n      prod:\r\n        deletion_policy: Retain\r\n", "ContentLicense": "CC BY-SA 3.0", "filtered-sentences": [{"source": "Text", "text": "There is no problem related to `test2`. ", "keywords": ["test"]}, {"source": "Text", "text": "For `test1`, you are fine to `sls deploy` many times, it should update for you. ", "keywords": ["test"]}, {"source": "Text", "text": "You found the open ticket already for a new feature to skip resources. ", "keywords": ["feature"]}, {"source": "Text", "text": "We have to wait for the feature to be developed and merged. ", "keywords": ["feature"]}]}, {"Id": "192190166", "PostHistoryTypeId": "5", "PostId": "47539611", "RevisionGUID": "b80bf144-d781-47f6-a548-b13aeabf1092", "CreationDate": "2019-02-22T09:30:15.953", "UserId": "498256", "Comment": "added 50 characters in body", "Text": "There is no problem related to `test2`. \r\n\r\nFor `test1`, you are fine to `sls deploy` many times.\r\n\r\nBut if you run `sls remove`, when the dynamodb is set to  `Retain`  in `serverless.yml`, the dynamodb table isn't deleted. So you can't create it again with `sls deploy`, because the resource with same name is exist. This is the design in aws cloudformation. \r\n\r\nYou found the open ticket already for a new feature to skip resources. We have to wait for the feature to be developed and merged. I am waiting for the same solution as well. Go there to vote it up!\r\n\r\nWith current situation, you have to backup the dynamodb, destroy it, and run `sls deploy`, and restore it if it is really matter.\r\n\r\nI normally manage with variable, such as `DeletionPolicy: ${self:custom.${self:custom.stage}.deletion_policy}` in custom for different environments:\r\n\r\n    custom\r\n      dev:\r\n        deletion_policy: Delete\r\n      prod:\r\n        deletion_policy: Retain\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "There is no problem related to `test2`. ", "keywords": ["test"]}, {"source": "Text", "text": "For `test1`, you are fine to `sls deploy` many times. ", "keywords": ["test"]}, {"source": "Text", "text": "You found the open ticket already for a new feature to skip resources. ", "keywords": ["feature"]}, {"source": "Text", "text": "We have to wait for the feature to be developed and merged. ", "keywords": ["feature"]}]}, {"Id": "198569744", "PostHistoryTypeId": "5", "PostId": "47539611", "RevisionGUID": "156dd630-30c5-4843-a363-466d75b25668", "CreationDate": "2019-05-28T02:46:04.717", "UserId": "498256", "Comment": "added 9 characters in body", "Text": "There is no problem related to `test2`. \r\n\r\nFor `test1`, you are fine to `sls deploy` many times.\r\n\r\nBut if you run `sls remove`, when the dynamodb is set to  `Retain`  in `serverless.yml`, the dynamodb table isn't deleted. So you can't create it again with `sls deploy`, because the resource with same name is exist. This is the design in aws cloudformation. \r\n\r\nYou found the open ticket already for a new feature to skip resources. We have to wait for the feature to be developed and merged. I am waiting for the same solution as well. Go there to vote it up!\r\n\r\nWith current situation, you have to backup the dynamodb, destroy it, and run `sls deploy`, and restore it if it is really matter.\r\n\r\nI normally manage with variable, such as \r\n\r\n    DeletionPolicy: ${self:custom.${self:custom.stage}.deletion_policy}\r\n\r\nin custom for different environments:\r\n\r\n    custom\r\n      dev:\r\n        deletion_policy: Delete\r\n      prod:\r\n        deletion_policy: Retain\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "There is no problem related to `test2`. ", "keywords": ["test"]}, {"source": "Text", "text": "For `test1`, you are fine to `sls deploy` many times. ", "keywords": ["test"]}, {"source": "Text", "text": "You found the open ticket already for a new feature to skip resources. ", "keywords": ["feature"]}, {"source": "Text", "text": "We have to wait for the feature to be developed and merged. ", "keywords": ["feature"]}]}], "filtered-sentences": [{"source": "Body", "text": "There is no problem related to test2. ", "keywords": ["test"]}, {"source": "Body", "text": "For test1, you are fine to sls deploy many times. ", "keywords": ["test"]}, {"source": "Body", "text": "You found the open ticket already for a new feature to skip resources. ", "keywords": ["feature"]}, {"source": "Body", "text": "We have to wait for the feature to be developed and merged. ", "keywords": ["feature"]}]}, {"Id": "51359804", "PostTypeId": "2", "ParentId": "47536542", "CreationDate": "2018-07-16T10:33:13.027", "Score": "1", "Body": "<p>Just to clarify the point, despite you have 2 serverless.yml files, as the service name is the same for both (sandbox-core) the deployment of <strong>test1</strong> or <strong>test2</strong> will affect the <strong>same</strong> cloud formation template.</p>\n\n<p>This means that when you deploy <strong>test2</strong> you are deliberately removing the track of the Dynamo Tables from the template and in a subsequent deploy of <strong>test1</strong> Cloud Formation will be unable to create a resource with the same name (as you already deleted from the template)</p>\n\n<p>If you want to avoid data loss, setting the policy to <em>Retain</em> should do the trick but you need to merge both serverless.yml into one. Then DynamoDB tables will never being removed from the template.</p>\n\n<p>What can help you to solve the issue (as the tables are already created with data) is to create a backup of your tables, deploy the joint serverless.yml files as one unique service with the tables included, manually remove the tables from the console, and restore the backups with <strong>exact the same name</strong> as the ones created by Cloud Formation. This will ensure that your template still has the reference to the ARNs of the tables.</p>\n", "OwnerUserId": "8252308", "LastActivityDate": "2018-07-16T10:33:13.027", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "177731019", "PostHistoryTypeId": "2", "PostId": "51359804", "RevisionGUID": "8468e823-ed7b-4ade-9a9c-b9f621d5d170", "CreationDate": "2018-07-16T10:33:13.027", "UserId": "8252308", "Text": "Just to clarify the point, despite you have 2 serverless.yml files, as the service name is the same for both (sandbox-core) the deployment of **test1** or **test2** will affect the **same** cloud formation template.\r\n\r\nThis means that when you deploy **test2** you are deliberately removing the track of the Dynamo Tables from the template and in a subsequent deploy of **test1** Cloud Formation will be unable to create a resource with the same name (as you already deleted from the template)\r\n\r\nIf you want to avoid data loss, setting the policy to *Retain* should do the trick but you need to merge both serverless.yml into one. Then DynamoDB tables will never being removed from the template.\r\n\r\nWhat can help you to solve the issue (as the tables are already created with data) is to create a backup of your tables, deploy the joint serverless.yml files as one unique service with the tables included, manually remove the tables from the console, and restore the backups with **exact the same name** as the ones created by Cloud Formation. This will ensure that your template still has the reference to the ARNs of the tables.\r\n\r\n", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "Just to clarify the point, despite you have 2 serverless.yml files, as the service name is the same for both (sandbox-core) the deployment of **test1** or **test2** will affect the **same** cloud formation template. ", "keywords": ["test"]}, {"source": "Text", "text": "This means that when you deploy **test2** you are deliberately removing the track of the Dynamo Tables from the template and in a subsequent deploy of **test1** Cloud Formation will be unable to create a resource with the same name (as you already deleted from the template) ", "keywords": ["test"]}, {"source": "Text", "text": "If you want to avoid data loss, setting the policy to *Retain* should do the trick but you need to merge both serverless.yml into one. ", "keywords": ["policy"]}]}], "filtered-sentences": [{"source": "Body", "text": "Just to clarify the point, despite you have 2 serverless.yml files, as the service name is the same for both (sandbox-core) the deployment of test1 or test2 will affect the same cloud formation template. ", "keywords": ["test"]}, {"source": "Body", "text": "This means that when you deploy test2 you are deliberately removing the track of the Dynamo Tables from the template and in a subsequent deploy of test1 Cloud Formation will be unable to create a resource with the same name (as you already deleted from the template) ", "keywords": ["test"]}, {"source": "Body", "text": "If you want to avoid data loss, setting the policy to Retain should do the trick but you need to merge both serverless.yml into one. ", "keywords": ["policy"]}]}], "contains-topic": true, "filtered-sentences": [{"source": "Body", "text": "One of them (let's call it, \"test1\") have resources (DynamoDB tables), the other hasn't (\"test2\"). ", "keywords": ["test"]}, {"source": "Body", "text": "Like the following snippets: Test1 Test2 ", "keywords": ["test"]}, {"source": "Body", "text": "When i sls deploy the \"test1\", he creates the tables as i wanted, with DeletionPolicy: Retain, for the tables with very sensible data. ", "keywords": ["test"]}, {"source": "Body", "text": "Then i sls deploy \"test2\" that has other functions but doesn't have any resources (DynamoDB tables), he does what is expected: skip the deletion of the tables. ", "keywords": ["test"]}, {"source": "Body", "text": "But, when i sls deploy \"test1\" again, he doesn't recognizes the tables, he starts to \"create\" existing tables rather than update them, and fails to deploy. ", "keywords": ["test"]}, {"source": "Body", "text": "I need the tables that are running, it has a lot of data and it's too much expensive to backup and restore it to another one, a lot of users could be affected. ", "keywords": ["expense"]}]}
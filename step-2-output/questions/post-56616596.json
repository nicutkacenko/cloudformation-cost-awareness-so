{"Id": "56616596", "PostTypeId": "1", "CreationDate": "2019-06-16T06:19:13.560", "Score": "1", "ViewCount": "2077", "Body": "<p>I'd like to \"truncate\" (delete all items) in a DynamoDB table. I know that the most efficient way to do this would be to delete the table and re-create it (name, indexes, etc.). However, the table is part of a SAM-CloudFormation deployment. The table (by name) is also referenced within other parts of the application.</p>\n\n<p>If I deleted and re-created it, I could use the same name it had previously; however, I think this would cause problems because (1) the deletion isn't immediate and (2) the ARN would change and that could have implications on the CloudFormation stack.</p>\n\n<p>It seems that there should be a better solution than the brute-force approach: iterate through all items, deleting them one at a time (with some optimization via the <code>batch_writer</code>).</p>\n\n<p>I've looked at some other solutions here, but they don't address the \"part of a CloudFormation stack\" part of my question.</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/42302316/truncate-dynamodb-or-rewrite-data-via-data-pipeline/42687853#42687853\">Truncate DynamoDb or rewrite data via Data Pipeline</a></li>\n<li><a href=\"https://stackoverflow.com/questions/9154264/what-is-the-recommended-way-to-delete-a-large-number-of-items-from-dynamodb/50723739#50723739\">What is the recommended way to delete a large number of items from DynamoDB?</a></li>\n</ul>\n\n<p>I even provided a brute-force solution myself to another's question on this topic.</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/55169952/delete-all-items-dynamodb-using-python/56616499#56616499\">delete all items DynamoDB using Python</a></li>\n</ul>\n\n<p>Here is the brute force approach</p>\n\n<pre><code>import boto3\n\ntable = boto3.resource('dynamodb').Table('my-table-name')\nscan = None\n\nwith table.batch_writer() as batch:\n    count = 0\n    while scan is None or 'LastEvaluatedKey' in scan:\n        if scan is not None and 'LastEvaluatedKey' in scan:\n            scan = table.scan(\n                ProjectionExpression='id',\n                ExclusiveStartKey=scan['LastEvaluatedKey'],\n            )\n        else:\n            scan = table.scan(ProjectionExpression='id')\n\n        for item in scan['Items']:\n            if count % 5000 == 0:\n                print(count)\n            batch.delete_item(Key={'id': item['id']})\n            count = count + 1\n</code></pre>\n\n<p>The desired final state is a DynamoDB table (that was previously full of items) with the same name, no items, and still able to be destroyed as part of a CloudFormation delete operation.</p>\n", "OwnerUserId": "10012948", "LastActivityDate": "2019-06-16T06:49:27.287", "Title": "\"Truncating\" a DynamoDB Table Created via CloudFormation (SAM)", "Tags": "|python|amazon-web-services|amazon-dynamodb|aws-cloudformation|", "AnswerCount": "1", "CommentCount": "1", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "101058672", "PostId": "56616596", "Score": "0", "Text": "Make sure you scan consistently with `ConsistentRead: True`, otherwise you may get the same items repeatedly if you scan fast enough after a batch write delete.", "CreationDate": "2019-07-30T23:26:54.857", "UserId": "6029837", "filtered-sentences": []}], "history": [{"Id": "199759830", "PostHistoryTypeId": "2", "PostId": "56616596", "RevisionGUID": "ee8e587d-09d5-4ca7-a819-7e5457502d0e", "CreationDate": "2019-06-16T06:19:13.560", "UserId": "10012948", "Text": "I'd like to \"truncate\" (delete all items) in a DynamoDB table. I know that the most efficient way to do this would be to delete the table and re-create it (name, indexes, etc.). However, the table is part of a SAM-CloudFormation deployment. The table (by name) is also referenced within other parts of the application.\r\n\r\nIf I deleted and re-created it, I could use the same name it had previously; however, I think this would cause problems because (1) the deletion isn't immediate and (2) the ARN would change and that could have implications on the CloudFormation stack.\r\n\r\nIt seems that there should be a better solution than the brute-force approach: iterate through all items, deleting them one at a time (with some optimization via the `batch_writer`).\r\n\r\nI've looked at some other solutions here, but they don't address the \"part of a CloudFormation stack\" part of my question.\r\n\r\n* https://stackoverflow.com/questions/42302316/truncate-dynamodb-or-rewrite-data-via-data-pipeline/42687853#42687853\r\n* https://stackoverflow.com/questions/9154264/what-is-the-recommended-way-to-delete-a-large-number-of-items-from-dynamodb/50723739#50723739\r\n\r\nI even provided a brute-force solution myself to another's question on this topic.\r\n\r\n* https://stackoverflow.com/questions/55169952/delete-all-items-dynamodb-using-python/56616499#56616499\r\n\r\nHere is the brute force approach\r\n\r\n```\r\nimport boto3\r\n\r\ntable = boto3.resource('dynamodb').Table('my-table-name')\r\nscan = None\r\n\r\nwith table.batch_writer() as batch:\r\n    count = 0\r\n    while scan is None or 'LastEvaluatedKey' in scan:\r\n        if scan is not None and 'LastEvaluatedKey' in scan:\r\n            scan = table.scan(\r\n                ProjectionExpression='id',\r\n                ExclusiveStartKey=scan['LastEvaluatedKey'],\r\n            )\r\n        else:\r\n            scan = table.scan(ProjectionExpression='id')\r\n\r\n        for item in scan['Items']:\r\n            if count % 5000 == 0:\r\n                print(count)\r\n            batch.delete_item(Key={'id': item['id']})\r\n            count = count + 1\r\n```\r\n\r\nThe desired final state is a DynamoDB table (that was previously full of items) with the same name, no items, and still able to be destroyed as part of a CloudFormation delete operation.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "I know that the most efficient way to do this would be to delete the table and re-create it (name, indexes, etc.). ", "keywords": ["efficient"]}, {"source": "Text", "text": "If I deleted and re-created it, I could use the same name it had previously; however, I think this would cause problems because (1) the deletion isn't immediate and (2) the ARN would change and that could have implications on the CloudFormation stack. ", "keywords": ["change"]}]}, {"Id": "199759831", "PostHistoryTypeId": "1", "PostId": "56616596", "RevisionGUID": "ee8e587d-09d5-4ca7-a819-7e5457502d0e", "CreationDate": "2019-06-16T06:19:13.560", "UserId": "10012948", "Text": "\"Truncating\" a DynamoDB Table Created via CloudFormation (SAM)", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "199759832", "PostHistoryTypeId": "3", "PostId": "56616596", "RevisionGUID": "ee8e587d-09d5-4ca7-a819-7e5457502d0e", "CreationDate": "2019-06-16T06:19:13.560", "UserId": "10012948", "Text": "|python|amazon-web-services|amazon-dynamodb|aws-cloudformation|", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "answers": [{"Id": "56616735", "PostTypeId": "2", "ParentId": "56616596", "CreationDate": "2019-06-16T06:49:27.287", "Score": "3", "Body": "<p>No matter if you created the table as <a href=\"https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#awsserverlesssimpletable\" rel=\"nofollow noreferrer\">AWS::Serverless::SimpleTable</a> or <a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-dynamodb-table.html\" rel=\"nofollow noreferrer\">AWS::DynamoDB::Table</a> there is no out-of-the-box solution to empty it using CloudFormation while keeping its name.</p>\n\n<p>As a general best practice you shouldn't name DynamoDB tables created by CloudFormation, but let CloudFormation assign a name for the resource. If that would have been the case in your setup you could simply do a change to the resource which requires \"replacement\" of the resource, like temporary adding a Local Secondary Index, which would recreate the resource and would work with resources depending on it.</p>\n\n<p>That said, in your situation the best approach is probably be to wrap your brute force approach in a <a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-custom-resources.html\" rel=\"nofollow noreferrer\">CloudFormation custom resource</a> and include that in your CloudFormation stack. With that you can truncate the table once or, depending on the implementation of your custom resource, whenever you want.</p>\n\n<p>Keep in mind that deleting all items from a DynamoDB table might take quite long, so using a Lambda-backed custom resource might run into the limit of Lambda function runtime, depending on the number of items in the table. It might also become quite costly if the table contains a lot of items.</p>\n", "OwnerUserId": "4779904", "LastActivityDate": "2019-06-16T06:49:27.287", "CommentCount": "4", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "99843369", "PostId": "56616735", "Score": "0", "Text": "I think the idea to force a \"truncate\" by doing two changes to the template is really interesting. \u00bfIs something like this what you're thinking/suggesting? (regarding the \"replacement\" option). Use [boto's stack update](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cloudformation.html#CloudFormation.Stack.update) to make a change that forces replacement (ex. change the [table's key schema](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-dynamodb-table.html#cfn-dynamodb-table-keyschema)) and then change it back to the way it was.", "CreationDate": "2019-06-17T17:22:07.247", "UserId": "10012948", "filtered-sentences": [{"source": "Text", "text": "I think the idea to force a \"truncate\" by doing two changes to the template is really interesting. ", "keywords": ["change"]}, {"source": "Text", "text": "Use [boto's stack update](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cloudformation.html#CloudFormation.Stack.update) to make a change that forces replacement (ex. change the [table's key schema](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-dynamodb-table.html#cfn-dynamodb-table-keyschema)) and then change it back to the way it was.", "keywords": ["change"]}]}, {"Id": "99853509", "PostId": "56616735", "Score": "0", "Text": "Yes, that's the idea. That doesn't work though if you rely on a manually set name for the table (as you do according to your question), as that'd result in CloudFormation trying to replace a resource identified by one ARN with another resource identified by the same ARN (as CloudFormation creates the new resource before deleting the old one (see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html for reference)).", "CreationDate": "2019-06-18T03:39:18.063", "UserId": "4779904", "filtered-sentences": []}, {"Id": "99888138", "PostId": "56616735", "Score": "0", "Text": "Got it. Thanks so much. I want using the name when creating it but I see where I've written that. I was thinking of dynamically getting the name (as set by CF) right before delete and then creating a table with that same name via API. If the arn is based on the table name, might this work?", "CreationDate": "2019-06-19T02:37:52.067", "UserId": "10012948", "filtered-sentences": []}, {"Id": "99889616", "PostId": "56616735", "Score": "0", "Text": "Sorry. I meant \"I WASN'T using a name when creating...\"", "CreationDate": "2019-06-19T04:48:06.310", "UserId": "10012948", "filtered-sentences": []}], "history": [{"Id": "199760427", "PostHistoryTypeId": "2", "PostId": "56616735", "RevisionGUID": "e8fd0e84-fe1b-44c4-bdbd-085e765f5389", "CreationDate": "2019-06-16T06:49:27.287", "UserId": "4779904", "Text": "No matter if you created the table as [AWS::Serverless::SimpleTable][1] or [AWS::DynamoDB::Table][2] there is no out-of-the-box solution to empty it using CloudFormation while keeping its name.\r\n\r\nAs a general best practice you shouldn't name DynamoDB tables created by CloudFormation, but let CloudFormation assign a name for the resource. If that would have been the case in your setup you could simply do a change to the resource which requires \"replacement\" of the resource, like temporary adding a Local Secondary Index, which would recreate the resource and would work with resources depending on it.\r\n\r\nThat said, in your situation the best approach is probably be to wrap your brute force approach in a [CloudFormation custom resource][3] and include that in your CloudFormation stack. With that you can truncate the table once or, depending on the implementation of your custom resource, whenever you want.\r\n\r\nKeep in mind that deleting all items from a DynamoDB table might take quite long, so using a Lambda-backed custom resource might run into the limit of Lambda function runtime, depending on the number of items in the table. It might also become quite costly if the table contains a lot of items.\r\n\r\n  [1]: https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#awsserverlesssimpletable\r\n  [2]: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-dynamodb-table.html\r\n  [3]: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-custom-resources.html", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "If that would have been the case in your setup you could simply do a change to the resource which requires \"replacement\" of the resource, like temporary adding a Local Secondary Index, which would recreate the resource and would work with resources depending on it. ", "keywords": ["change"]}]}], "filtered-sentences": [{"source": "Body", "text": "If that would have been the case in your setup you could simply do a change to the resource which requires \"replacement\" of the resource, like temporary adding a Local Secondary Index, which would recreate the resource and would work with resources depending on it. ", "keywords": ["change"]}]}], "contains-topic": true, "filtered-sentences": [{"source": "Body", "text": "I know that the most efficient way to do this would be to delete the table and re-create it (name, indexes, etc.). ", "keywords": ["efficient"]}, {"source": "Body", "text": "If I deleted and re-created it, I could use the same name it had previously; however, I think this would cause problems because (1) the deletion isn't immediate and (2) the ARN would change and that could have implications on the CloudFormation stack. ", "keywords": ["change"]}]}
{"Id": "58317315", "PostTypeId": "1", "CreationDate": "2019-10-10T07:11:00.907", "Score": "0", "ViewCount": "1320", "Body": "<p>I have a requirement of <strong>creating an ECS Cluster without using autoscaling</strong>.</p>\n\n<p>This is because of <strong>a Dedicated Host (DH), Tenancy=Host, is not supported with ASGs</strong>.  DH is mainly for cost savings and for some cases because of the savings is worth doing even if we can't use ASGs.</p>\n\n<p>I understand this can be done using <strong>Macros</strong> and <strong>Custom Resources backed up with Lambda</strong> or using <strong>Troposphere</strong> to loop over the instance.</p>\n\n<p>But to start with any example of the same or any other approach would be really appreciated .</p>\n\n<p>Below is my appsec.yaml template file:</p>\n\n<pre><code>AWSTemplateFormatVersion: 2010-09-09\nDescription: Provision Platform Container Service\n\nParameters:\n  PlatformCluster:\n    Type: String\n  PlatformClusterNotifications:\n    Type: String\n  PlatformClusterLifecycleNotification:\n    Type: String\n  Product:\n    Type: String\n  Environment:\n    Type: String\n  CDRevisionLoc: \n    Type: String\n  ClusterIdentifier:\n    Type: Number\n  ClusterMinSize:\n    Type: Number\n  ClusterMaxSize:\n    Type: Number\n  ClusterSubnets: \n    Type: List&lt;AWS::EC2::Subnet::Id&gt;    \n  NodeImageId: \n    Type: AWS::EC2::Image::Id\n  NodeOSVolumeSize: \n    Type: Number\n    MinValue: 8\n  NodeInstanceRole:\n    Type: String\n  NodeInstanceProfile: \n    Type: String\n  NodeKeyName:\n    Type: AWS::EC2::KeyPair::KeyName\n  NodeInstanceType:\n    Type: String\n  NodeSecurityGroups:\n    Type: List&lt;AWS::EC2::SecurityGroup::Id&gt;\n  HanoverSchedule: \n    Type: String \n\nMappings:\n  InstanceStoreDevices:\n    \"i3.2xlarge\":\n      DEVS: \"/dev/nvme0n1\"\n    \"i3.4xlarge\":\n      DEVS: \"/dev/nvme0n1 /dev/nvme1n1\"\n    \"i3.8xlarge\":\n      DEVS: \"/dev/nvme0n1 /dev/nvme1n1 /dev/nvme2n1 /dev/nvme3n1\"\n    \"m5d.2xlarge\":\n      DEVS: \"/dev/nvme1n1\"\n    \"m5d.4xlarge\":\n      DEVS: \"/dev/nvme1n1 /dev/nvme2n1\"\n    \"c5d.2xlarge\":\n      DEVS: \"/dev/nvme1n1\"\n    \"c5d.4xlarge\":\n      DEVS: \"/dev/nvme1n1\"\n    \"c5d.9xlarge\":\n      DEVS: \"/dev/nvme1n1\"\n\nResources:  \n  PlatformClusterLaunchConfiguration:\n    Type: AWS::AutoScaling::LaunchConfiguration\n    Metadata:\n      AWS::CloudFormation::Init:\n        configSets:\n          all: [install_cfn, update_ecs_agent, faro_self_install]\n        install_cfn:\n          files:\n            /etc/cfn/cfn-hup.conf:\n              content: !Sub |\n                [main]\n                stack=${AWS::StackId}\n                region=${AWS::Region}\n                interval=5\n              mode: '000400'\n              owner: root\n              group: root\n            /etc/cfn/hooks.d/cfn-auto-reloader.conf:\n              content: !Sub |\n                [cfn-auto-reloader-hook]\n                runas=root\n                triggers=post.update\n                path=Resources.PlatformClusterLaunchConfiguration.Metadata.AWS::CloudFormation::Init\n                action=/opt/aws/bin/cfn-init -v --stack ${AWS::StackName} --resource PlatformClusterLaunchConfiguration --configsets all --region ${AWS::Region}\n              mode: '000400'\n              owner: root\n              group: root\n          services:\n            sysvinit:\n              cfn-hup:\n                enabled: True\n                ensureRunning: True\n                files: [/etc/cfn/cfn-hup.conf, /etc/cfn/hooks.d/cfn-auto-reloader.conf]\n        update_ecs_agent:\n          commands:\n            update_agent:\n              command: yum update -y ecs-init\n        faro_self_install:\n          packages:\n            yum:\n              ruby: []\n              aws-cli: []\n              python27: []\n              python27-boto3: []\n              epel-release: [] \n              unzip: [] \n              ack: []\n              wget: []\n              jq: []\n          commands:\n            self_install:\n              command: !Sub |\n                #!/bin/bash\n                yum -y --security update\n\n                mkdir -p /etc/salt\n                cd $(mktemp -d)\n                REVNAME=$(basename ${CDRevisionLoc})\n                aws --region ${AWS::Region} s3 cp ${CDRevisionLoc} $REVNAME.zip\n                unzip -o $REVNAME.zip -d $REVNAME\n                chmod +x $REVNAME/install.sh\n                ./$REVNAME/install.sh\n    Properties:\n      BlockDeviceMappings:\n        - DeviceName: /dev/xvda\n          Ebs:\n            VolumeSize: !Ref NodeOSVolumeSize\n            VolumeType: gp2\n            DeleteOnTermination: True\n        - DeviceName: /dev/xvdcz\n          VirtualName: ephemeral0\n      EbsOptimized: True\n      IamInstanceProfile: !Ref NodeInstanceProfile\n      ImageId: !Ref NodeImageId\n      InstanceMonitoring: True\n      InstanceType: !Ref NodeInstanceType\n      KeyName: !Ref NodeKeyName\n      SecurityGroups: !Ref NodeSecurityGroups\n      UserData: \n        Fn::Base64: \n          Fn::Sub: \n            - |\n              Content-Type: multipart/mixed; boundary=\"**\"\n              MIME-Version: 1.0\n\n              --**\n              MIME-Version: 1.0\n              Content-Type: text/cloud-boothook; charset=\"us-ascii\"\n\n              cloud-init-per once yum_update yum update -y\n              cloud-init-per once install_aws_cfn_bootstrap yum -y install aws-cfn-bootstrap\n\n              cloud-init-per instance custom_docker_options cat &lt;&lt;'EOF' &gt; /etc/sysconfig/docker\n              DAEMON_MAXFILES=1048576\n              DAEMON_PIDFILE_TIMEOUT=10\n              OPTIONS=\"--default-ulimit nofile=1024:4096\"\n              EOF\n\n              cloud-init-per instance custom_docker_storage_options cat &lt;&lt;'EOF' &gt; /etc/sysconfig/docker-storage-setup\n              DEVS=\"${InstanceStoreDevices}\"\n              STORAGE_DRIVER=\"devicemapper\"\n              VG=docker\n              DATA_SIZE=99%FREE\n              AUTO_EXTEND_POOL=yes\n              LV_ERROR_WHEN_FULL=yes\n              EXTRA_DOCKER_STORAGE_OPTIONS=\"--storage-opt dm.fs=ext4 --storage-opt dm.use_deferred_deletion=true --storage-opt dm.basesize=20G\"\n              EOF\n\n              cloud-init-per instance custom_ecs_options cat &lt;&lt;'EOF' &gt; /etc/ecs/ecs.config\n              ECS_CLUSTER=${PlatformCluster}\n              ECS_ENABLE_TASK_IAM_ROLE=true\n              ECS_ENABLE_TASK_IAM_ROLE_NETWORK_HOST=true \n              ECS_DISABLE_PRIVILEGED=true \n              ECS_AVAILABLE_LOGGING_DRIVERS=[\"json-file\", \"awslogs\", \"splunk\"] \n              ECS_SELINUX_CAPABLE=false \n              ECS_APPARMOR_CAPABLE=false \n              ECS_ENGINE_TASK_CLEANUP_WAIT_DURATION=10m \n              ECS_CONTAINER_STOP_TIMEOUT=1m \n              ECS_DISABLE_IMAGE_CLEANUP=false \n              ECS_IMAGE_CLEANUP_INTERVAL=30m \n              ECS_IMAGE_MINIMUM_CLEANUP_AGE=30m \n              ECS_NUM_IMAGES_DELETE_PER_CYCLE=50 \n              ECS_UPDATES_ENABLED=false \n              ECS_DISABLE_METRICS=false \n              ECS_ENABLE_CONTAINER_METADATA=true \n              ECS_AWSVPC_ADDITIONAL_LOCAL_ROUTES=[\"169.254.120.120/32\"] \n              EOF\n\n              --**\n              MIME-Version: 1.0\n              Content-Type: text/x-shellscript; charset=\"us-ascii\"\n\n              #!/bin/bash\n              set -e\n\n              # set sysctl before doing anything\n              echo \"net.ipv4.conf.all.forwarding = 1\" &gt;&gt; /etc/sysctl.d/99-local.conf\n              sysctl net.ipv4.conf.all.forwarding=1\n\n              /opt/aws/bin/cfn-init -v --stack ${AWS::StackName} --resource PlatformClusterLaunchConfiguration --configsets all --region ${AWS::Region}\n              /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource PlatformClusterASG --region ${AWS::Region}\n            - PlatformCluster: !Ref PlatformCluster\n              InstanceStoreDevices: !FindInMap [InstanceStoreDevices, !Ref NodeInstanceType, \"DEVS\"]\n\n\n  PlatformClusterASG:\n    Type: \"AWS::AutoScaling::AutoScalingGroup\"\n    DependsOn:\n      - PlatformClusterLaunchConfiguration\n    Properties:\n      Cooldown: 900\n      HealthCheckGracePeriod: 600\n      HealthCheckType: EC2\n      LaunchConfigurationName: !Ref PlatformClusterLaunchConfiguration\n      VPCZoneIdentifier: !Ref ClusterSubnets\n      MaxSize: !Ref ClusterMaxSize\n      MinSize: !Ref ClusterMinSize\n      DesiredCapacity: !Ref ClusterMinSize\n      MetricsCollection:\n        - \n          Granularity: 1Minute\n      NotificationConfigurations:\n        -\n          NotificationTypes:\n            - autoscaling:EC2_INSTANCE_LAUNCH_ERROR\n            - autoscaling:EC2_INSTANCE_TERMINATE_ERROR\n          TopicARN: !Ref PlatformClusterNotifications\n      TerminationPolicies:\n        - NewestInstance\n      Tags:\n        - Key: Name\n          Value: !Sub ${Product}${Environment}-pcs${ClusterIdentifier}\n          PropagateAtLaunch: true\n        - Key: Product\n          Value: !Ref Product\n          PropagateAtLaunch: true\n        - Key: Environment\n          Value: !Ref Environment\n          PropagateAtLaunch: true\n        - Key: Service\n          Value: !Sub gtn:${Environment}:pcs\n          PropagateAtLaunch: true\n        - Key: Schedule\n          Value: !Ref HanoverSchedule\n          PropagateAtLaunch: true\n    CreationPolicy:\n      ResourceSignal:\n        Timeout: PT20M\n    UpdatePolicy:\n      AutoScalingRollingUpdate:\n        WaitOnResourceSignals: True\n        PauseTime: PT20M\n      AutoScalingScheduledAction:\n        IgnoreUnmodifiedGroupSizeProperties: True\n\n  PlatformClusterTeardownLifecycleHook:\n    Type: \"AWS::AutoScaling::LifecycleHook\"\n    DependsOn:\n      - PlatformClusterASG\n    Properties:\n      AutoScalingGroupName: !Ref PlatformClusterASG\n      DefaultResult: ABANDON\n      HeartbeatTimeout: 900\n      LifecycleTransition: autoscaling:EC2_INSTANCE_TERMINATING\n      NotificationTargetARN: !Ref PlatformClusterLifecycleNotification\n      RoleARN: !Ref NodeInstanceRole\n\nOutputs:\n  ECSAutoScalingGroup:\n    Value: !Ref PlatformClusterASG\n\n</code></pre>\n", "OwnerUserId": "11723467", "LastEditorUserId": "11723467", "LastEditDate": "2019-10-10T07:18:26.173", "LastActivityDate": "2019-10-15T22:34:31.323", "Title": "ECS cluster without Autoscaling", "Tags": "|amazon-ec2|aws-lambda|aws-cloudformation|amazon-ecs|autoscaling|", "AnswerCount": "1", "CommentCount": "3", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "102998505", "PostId": "58317315", "Score": "1", "Text": "I'm not 100% sure about DH, but you could pin your instance to ECS Cluster (if you have ecs-agent installed on instance) by putting `ECS_CLUSTER=YOUR_CLUSTER_NAME` in `/etc/ecs/ecs.config` (you can do it in `user data` scripts)", "CreationDate": "2019-10-10T09:26:02.860", "UserId": "6885868", "filtered-sentences": [{"source": "Text", "text": "I'm not 100% sure about DH, but you could pin your instance to ECS Cluster (if you have ecs-agent installed on instance) by putting `ECS_CLUSTER=YOUR_CLUSTER_NAME` in `/etc/ecs/ecs.config` (you can do it in `user data` scripts)", "keywords": ["instance", "cluster"]}]}, {"Id": "103004424", "PostId": "58317315", "Score": "0", "Text": "\"DH is mainly for cost savings\" There is no scenario where Dedicated Hosting offers cost savings over default \"shared\" tenancy.", "CreationDate": "2019-10-10T12:26:55.407", "UserId": "13070", "filtered-sentences": [{"source": "Text", "text": "\"DH is mainly for cost savings\" ", "keywords": ["cost"]}, {"source": "Text", "text": "There is no scenario where Dedicated Hosting offers cost savings over default \"shared\" tenancy.", "keywords": ["cost"]}]}, {"Id": "103028000", "PostId": "58317315", "Score": "0", "Text": "I am thinking of looping the instance creation using ansible. But even if I do this, how am I going to include this into my appsec.yml without having to save it into an S3 and incurring additional charges? @Yupik", "CreationDate": "2019-10-11T06:50:47.550", "UserId": "11723467", "filtered-sentences": [{"source": "Text", "text": "I am thinking of looping the instance creation using ansible. ", "keywords": ["instance"]}]}], "history": [{"Id": "206938761", "PostHistoryTypeId": "2", "PostId": "58317315", "RevisionGUID": "cd6e5f9b-339c-4b98-855e-c4d9c32131af", "CreationDate": "2019-10-10T07:11:00.907", "UserId": "11723467", "Text": "I have a requirement of **creating an ECS Cluster without using autoscaling**.\r\n\r\nThis is because of **a Dedicated Host (DH), Tenancy=Host, is not supported with ASGs**.  DH is mainly for cost savings and for some cases because of the savings is worth doing even if we can't use ASGs.\r\n\r\nI understand this can be done using **Macros** and **Custom Resources backed up with Lambda** or using **Troposphere** to loop over the instance.\r\n\r\nBut to start with any example of the same or any other approach would be really appreciated .", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "I have a requirement of **creating an ECS Cluster without using autoscaling**. ", "keywords": ["cluster"]}, {"source": "Text", "text": "DH is mainly for cost savings and for some cases because of the savings is worth doing even if we can't use ASGs. ", "keywords": ["cost"]}, {"source": "Text", "text": "I understand this can be done using **Macros** and **Custom Resources backed up with Lambda** or using **Troposphere** to loop over the instance. ", "keywords": ["instance"]}]}, {"Id": "206938762", "PostHistoryTypeId": "1", "PostId": "58317315", "RevisionGUID": "cd6e5f9b-339c-4b98-855e-c4d9c32131af", "CreationDate": "2019-10-10T07:11:00.907", "UserId": "11723467", "Text": "ECS cluster without Autoscaling", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "ECS cluster without Autoscaling", "keywords": ["cluster"]}]}, {"Id": "206938763", "PostHistoryTypeId": "3", "PostId": "58317315", "RevisionGUID": "cd6e5f9b-339c-4b98-855e-c4d9c32131af", "CreationDate": "2019-10-10T07:11:00.907", "UserId": "11723467", "Text": "|amazon-ec2|aws-lambda|aws-cloudformation|amazon-ecs|autoscaling|", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "206939274", "PostHistoryTypeId": "5", "PostId": "58317315", "RevisionGUID": "32023cc4-b36b-446e-9a7b-41a40c0c2952", "CreationDate": "2019-10-10T07:18:26.173", "UserId": "11723467", "Comment": "added 9409 characters in body", "Text": "I have a requirement of **creating an ECS Cluster without using autoscaling**.\r\n\r\nThis is because of **a Dedicated Host (DH), Tenancy=Host, is not supported with ASGs**.  DH is mainly for cost savings and for some cases because of the savings is worth doing even if we can't use ASGs.\r\n\r\nI understand this can be done using **Macros** and **Custom Resources backed up with Lambda** or using **Troposphere** to loop over the instance.\r\n\r\nBut to start with any example of the same or any other approach would be really appreciated .\r\n\r\nBelow is my appsec.yaml template file:\r\n\r\n```\r\nAWSTemplateFormatVersion: 2010-09-09\r\nDescription: Provision Platform Container Service\r\n\r\nParameters:\r\n  PlatformCluster:\r\n    Type: String\r\n  PlatformClusterNotifications:\r\n    Type: String\r\n  PlatformClusterLifecycleNotification:\r\n    Type: String\r\n  Product:\r\n    Type: String\r\n  Environment:\r\n    Type: String\r\n  CDRevisionLoc: \r\n    Type: String\r\n  ClusterIdentifier:\r\n    Type: Number\r\n  ClusterMinSize:\r\n    Type: Number\r\n  ClusterMaxSize:\r\n    Type: Number\r\n  ClusterSubnets: \r\n    Type: List<AWS::EC2::Subnet::Id>    \r\n  NodeImageId: \r\n    Type: AWS::EC2::Image::Id\r\n  NodeOSVolumeSize: \r\n    Type: Number\r\n    MinValue: 8\r\n  NodeInstanceRole:\r\n    Type: String\r\n  NodeInstanceProfile: \r\n    Type: String\r\n  NodeKeyName:\r\n    Type: AWS::EC2::KeyPair::KeyName\r\n  NodeInstanceType:\r\n    Type: String\r\n  NodeSecurityGroups:\r\n    Type: List<AWS::EC2::SecurityGroup::Id>\r\n  HanoverSchedule: \r\n    Type: String \r\n\r\nMappings:\r\n  InstanceStoreDevices:\r\n    \"i3.2xlarge\":\r\n      DEVS: \"/dev/nvme0n1\"\r\n    \"i3.4xlarge\":\r\n      DEVS: \"/dev/nvme0n1 /dev/nvme1n1\"\r\n    \"i3.8xlarge\":\r\n      DEVS: \"/dev/nvme0n1 /dev/nvme1n1 /dev/nvme2n1 /dev/nvme3n1\"\r\n    \"m5d.2xlarge\":\r\n      DEVS: \"/dev/nvme1n1\"\r\n    \"m5d.4xlarge\":\r\n      DEVS: \"/dev/nvme1n1 /dev/nvme2n1\"\r\n    \"c5d.2xlarge\":\r\n      DEVS: \"/dev/nvme1n1\"\r\n    \"c5d.4xlarge\":\r\n      DEVS: \"/dev/nvme1n1\"\r\n    \"c5d.9xlarge\":\r\n      DEVS: \"/dev/nvme1n1\"\r\n\r\nResources:  \r\n  PlatformClusterLaunchConfiguration:\r\n    Type: AWS::AutoScaling::LaunchConfiguration\r\n    Metadata:\r\n      AWS::CloudFormation::Init:\r\n        configSets:\r\n          all: [install_cfn, update_ecs_agent, faro_self_install]\r\n        install_cfn:\r\n          files:\r\n            /etc/cfn/cfn-hup.conf:\r\n              content: !Sub |\r\n                [main]\r\n                stack=${AWS::StackId}\r\n                region=${AWS::Region}\r\n                interval=5\r\n              mode: '000400'\r\n              owner: root\r\n              group: root\r\n            /etc/cfn/hooks.d/cfn-auto-reloader.conf:\r\n              content: !Sub |\r\n                [cfn-auto-reloader-hook]\r\n                runas=root\r\n                triggers=post.update\r\n                path=Resources.PlatformClusterLaunchConfiguration.Metadata.AWS::CloudFormation::Init\r\n                action=/opt/aws/bin/cfn-init -v --stack ${AWS::StackName} --resource PlatformClusterLaunchConfiguration --configsets all --region ${AWS::Region}\r\n              mode: '000400'\r\n              owner: root\r\n              group: root\r\n          services:\r\n            sysvinit:\r\n              cfn-hup:\r\n                enabled: True\r\n                ensureRunning: True\r\n                files: [/etc/cfn/cfn-hup.conf, /etc/cfn/hooks.d/cfn-auto-reloader.conf]\r\n        update_ecs_agent:\r\n          commands:\r\n            update_agent:\r\n              command: yum update -y ecs-init\r\n        faro_self_install:\r\n          packages:\r\n            yum:\r\n              ruby: []\r\n              aws-cli: []\r\n              python27: []\r\n              python27-boto3: []\r\n              epel-release: [] \r\n              unzip: [] \r\n              ack: []\r\n              wget: []\r\n              jq: []\r\n          commands:\r\n            self_install:\r\n              command: !Sub |\r\n                #!/bin/bash\r\n                yum -y --security update\r\n\r\n                mkdir -p /etc/salt\r\n                cd $(mktemp -d)\r\n                REVNAME=$(basename ${CDRevisionLoc})\r\n                aws --region ${AWS::Region} s3 cp ${CDRevisionLoc} $REVNAME.zip\r\n                unzip -o $REVNAME.zip -d $REVNAME\r\n                chmod +x $REVNAME/install.sh\r\n                ./$REVNAME/install.sh\r\n    Properties:\r\n      BlockDeviceMappings:\r\n        - DeviceName: /dev/xvda\r\n          Ebs:\r\n            VolumeSize: !Ref NodeOSVolumeSize\r\n            VolumeType: gp2\r\n            DeleteOnTermination: True\r\n        - DeviceName: /dev/xvdcz\r\n          VirtualName: ephemeral0\r\n      EbsOptimized: True\r\n      IamInstanceProfile: !Ref NodeInstanceProfile\r\n      ImageId: !Ref NodeImageId\r\n      InstanceMonitoring: True\r\n      InstanceType: !Ref NodeInstanceType\r\n      KeyName: !Ref NodeKeyName\r\n      SecurityGroups: !Ref NodeSecurityGroups\r\n      UserData: \r\n        Fn::Base64: \r\n          Fn::Sub: \r\n            - |\r\n              Content-Type: multipart/mixed; boundary=\"**\"\r\n              MIME-Version: 1.0\r\n\r\n              --**\r\n              MIME-Version: 1.0\r\n              Content-Type: text/cloud-boothook; charset=\"us-ascii\"\r\n              \r\n              cloud-init-per once yum_update yum update -y\r\n              cloud-init-per once install_aws_cfn_bootstrap yum -y install aws-cfn-bootstrap\r\n\r\n              cloud-init-per instance custom_docker_options cat <<'EOF' > /etc/sysconfig/docker\r\n              DAEMON_MAXFILES=1048576\r\n              DAEMON_PIDFILE_TIMEOUT=10\r\n              OPTIONS=\"--default-ulimit nofile=1024:4096\"\r\n              EOF\r\n\r\n              cloud-init-per instance custom_docker_storage_options cat <<'EOF' > /etc/sysconfig/docker-storage-setup\r\n              DEVS=\"${InstanceStoreDevices}\"\r\n              STORAGE_DRIVER=\"devicemapper\"\r\n              VG=docker\r\n              DATA_SIZE=99%FREE\r\n              AUTO_EXTEND_POOL=yes\r\n              LV_ERROR_WHEN_FULL=yes\r\n              EXTRA_DOCKER_STORAGE_OPTIONS=\"--storage-opt dm.fs=ext4 --storage-opt dm.use_deferred_deletion=true --storage-opt dm.basesize=20G\"\r\n              EOF\r\n\r\n              cloud-init-per instance custom_ecs_options cat <<'EOF' > /etc/ecs/ecs.config\r\n              ECS_CLUSTER=${PlatformCluster}\r\n              ECS_ENABLE_TASK_IAM_ROLE=true\r\n              ECS_ENABLE_TASK_IAM_ROLE_NETWORK_HOST=true \r\n              ECS_DISABLE_PRIVILEGED=true \r\n              ECS_AVAILABLE_LOGGING_DRIVERS=[\"json-file\", \"awslogs\", \"splunk\"] \r\n              ECS_SELINUX_CAPABLE=false \r\n              ECS_APPARMOR_CAPABLE=false \r\n              ECS_ENGINE_TASK_CLEANUP_WAIT_DURATION=10m \r\n              ECS_CONTAINER_STOP_TIMEOUT=1m \r\n              ECS_DISABLE_IMAGE_CLEANUP=false \r\n              ECS_IMAGE_CLEANUP_INTERVAL=30m \r\n              ECS_IMAGE_MINIMUM_CLEANUP_AGE=30m \r\n              ECS_NUM_IMAGES_DELETE_PER_CYCLE=50 \r\n              ECS_UPDATES_ENABLED=false \r\n              ECS_DISABLE_METRICS=false \r\n              ECS_ENABLE_CONTAINER_METADATA=true \r\n              ECS_AWSVPC_ADDITIONAL_LOCAL_ROUTES=[\"169.254.120.120/32\"] \r\n              EOF\r\n\r\n              --**\r\n              MIME-Version: 1.0\r\n              Content-Type: text/x-shellscript; charset=\"us-ascii\"\r\n\r\n              #!/bin/bash\r\n              set -e\r\n\r\n              # set sysctl before doing anything\r\n              echo \"net.ipv4.conf.all.forwarding = 1\" >> /etc/sysctl.d/99-local.conf\r\n              sysctl net.ipv4.conf.all.forwarding=1\r\n\r\n              /opt/aws/bin/cfn-init -v --stack ${AWS::StackName} --resource PlatformClusterLaunchConfiguration --configsets all --region ${AWS::Region}\r\n              /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource PlatformClusterASG --region ${AWS::Region}\r\n            - PlatformCluster: !Ref PlatformCluster\r\n              InstanceStoreDevices: !FindInMap [InstanceStoreDevices, !Ref NodeInstanceType, \"DEVS\"]\r\n\r\n\r\n  PlatformClusterASG:\r\n    Type: \"AWS::AutoScaling::AutoScalingGroup\"\r\n    DependsOn:\r\n      - PlatformClusterLaunchConfiguration\r\n    Properties:\r\n      Cooldown: 900\r\n      HealthCheckGracePeriod: 600\r\n      HealthCheckType: EC2\r\n      LaunchConfigurationName: !Ref PlatformClusterLaunchConfiguration\r\n      VPCZoneIdentifier: !Ref ClusterSubnets\r\n      MaxSize: !Ref ClusterMaxSize\r\n      MinSize: !Ref ClusterMinSize\r\n      DesiredCapacity: !Ref ClusterMinSize\r\n      MetricsCollection:\r\n        - \r\n          Granularity: 1Minute\r\n      NotificationConfigurations:\r\n        -\r\n          NotificationTypes:\r\n            - autoscaling:EC2_INSTANCE_LAUNCH_ERROR\r\n            - autoscaling:EC2_INSTANCE_TERMINATE_ERROR\r\n          TopicARN: !Ref PlatformClusterNotifications\r\n      TerminationPolicies:\r\n        - NewestInstance\r\n      Tags:\r\n        - Key: Name\r\n          Value: !Sub ${Product}${Environment}-pcs${ClusterIdentifier}\r\n          PropagateAtLaunch: true\r\n        - Key: Product\r\n          Value: !Ref Product\r\n          PropagateAtLaunch: true\r\n        - Key: Environment\r\n          Value: !Ref Environment\r\n          PropagateAtLaunch: true\r\n        - Key: Service\r\n          Value: !Sub gtn:${Environment}:pcs\r\n          PropagateAtLaunch: true\r\n        - Key: Schedule\r\n          Value: !Ref HanoverSchedule\r\n          PropagateAtLaunch: true\r\n    CreationPolicy:\r\n      ResourceSignal:\r\n        Timeout: PT20M\r\n    UpdatePolicy:\r\n      AutoScalingRollingUpdate:\r\n        WaitOnResourceSignals: True\r\n        PauseTime: PT20M\r\n      AutoScalingScheduledAction:\r\n        IgnoreUnmodifiedGroupSizeProperties: True\r\n  \r\n  PlatformClusterTeardownLifecycleHook:\r\n    Type: \"AWS::AutoScaling::LifecycleHook\"\r\n    DependsOn:\r\n      - PlatformClusterASG\r\n    Properties:\r\n      AutoScalingGroupName: !Ref PlatformClusterASG\r\n      DefaultResult: ABANDON\r\n      HeartbeatTimeout: 900\r\n      LifecycleTransition: autoscaling:EC2_INSTANCE_TERMINATING\r\n      NotificationTargetARN: !Ref PlatformClusterLifecycleNotification\r\n      RoleARN: !Ref NodeInstanceRole\r\n\r\nOutputs:\r\n  ECSAutoScalingGroup:\r\n    Value: !Ref PlatformClusterASG\r\n\r\n```", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "I have a requirement of **creating an ECS Cluster without using autoscaling**. ", "keywords": ["cluster"]}, {"source": "Text", "text": "DH is mainly for cost savings and for some cases because of the savings is worth doing even if we can't use ASGs. ", "keywords": ["cost"]}, {"source": "Text", "text": "I understand this can be done using **Macros** and **Custom Resources backed up with Lambda** or using **Troposphere** to loop over the instance. ", "keywords": ["instance"]}, {"source": "Text", "text": "AWSTemplateFormatVersion: 2010-09-09 Description: Provision Platform Container Service Parameters: PlatformCluster: Type: String PlatformClusterNotifications: Type: String PlatformClusterLifecycleNotification: Type: String Product: Type: String Environment: Type: String CDRevisionLoc: Type: String ClusterIdentifier: Type: Number ClusterMinSize: Type: Number ClusterMaxSize: Type: Number ClusterSubnets: Type: List NodeImageId: Type: AWS::EC2::Image::Id NodeOSVolumeSize: Type: Number MinValue: 8 NodeInstanceRole: Type: String NodeInstanceProfile: Type: String NodeKeyName: Type: AWS::EC2::KeyPair::KeyName NodeInstanceType: Type: String NodeSecurityGroups: Type: List HanoverSchedule: Type: String Mappings: InstanceStoreDevices: \"i3.2xlarge\": DEVS: \"/dev/nvme0n1\" \"i3.4xlarge\": DEVS: \"/dev/nvme0n1 /dev/nvme1n1\" \"i3.8xlarge\": DEVS: \"/dev/nvme0n1 /dev/nvme1n1 /dev/nvme2n1 /dev/nvme3n1\" \"m5d.2xlarge\": DEVS: \"/dev/nvme1n1\" \"m5d.4xlarge\": DEVS: \"/dev/nvme1n1 /dev/nvme2n1\" \"c5d.2xlarge\": DEVS: \"/dev/nvme1n1\" \"c5d.4xlarge\": DEVS: \"/dev/nvme1n1\" \"c5d.9xlarge\": DEVS: \"/dev/nvme1n1\" Resources: PlatformClusterLaunchConfiguration: Type: AWS::AutoScaling::LaunchConfiguration Metadata: AWS::CloudFormation::Init: configSets: all: [install_cfn, update_ecs_agent, faro_self_install] install_cfn: files: /etc/cfn/cfn-hup.conf: content: !Sub | [main] stack=${AWS::StackId} region=${AWS::Region} interval=5 mode: '000400' owner: root group: root /etc/cfn/hooks.d/cfn-auto-reloader.conf: content: !Sub | [cfn-auto-reloader-hook] runas=root triggers=post.update path=Resources.PlatformClusterLaunchConfiguration.Metadata.AWS::CloudFormation::Init action=/opt/aws/bin/cfn-init -v --stack ${AWS::StackName} --resource PlatformClusterLaunchConfiguration --configsets all --region ${AWS::Region} mode: '000400' owner: root group: root services: sysvinit: cfn-hup: enabled: True ensureRunning: True files: [/etc/cfn/cfn-hup.conf, /etc/cfn/hooks.d/cfn-auto-reloader.conf] update_ecs_agent: commands: update_agent: command: yum update -y ecs-init faro_self_install: packages: yum: ruby: [] aws-cli: [] python27: [] python27-boto3: [] epel-release: [] unzip: [] ack: [] wget: [] jq: [] commands: self_install: command: !Sub | #!/bin/bash yum -y --security update mkdir -p /etc/salt cd $(mktemp -d) REVNAME=$(basename ${CDRevisionLoc}) aws --region ${AWS::Region} s3 cp ${CDRevisionLoc} $REVNAME.zip unzip -o $REVNAME.zip -d $REVNAME chmod +x $REVNAME/install.sh ./$REVNAME/install.sh Properties: BlockDeviceMappings: - DeviceName: /dev/xvda Ebs: VolumeSize: !Ref NodeOSVolumeSize VolumeType: gp2 DeleteOnTermination: True - DeviceName: /dev/xvdcz VirtualName: ephemeral0 EbsOptimized: True IamInstanceProfile: !Ref NodeInstanceProfile ImageId: !Ref NodeImageId InstanceMonitoring: True InstanceType: !Ref NodeInstanceType KeyName: !Ref NodeKeyName SecurityGroups: !Ref NodeSecurityGroups UserData: Fn::Base64: Fn::Sub: - | Content-Type: multipart/mixed; boundary=\"**\" MIME-Version: 1.0 --** MIME-Version: 1.0 Content-Type: text/cloud-boothook; charset=\"us-ascii\" cloud-init-per once yum_update yum update -y cloud-init-per once install_aws_cfn_bootstrap yum -y install aws-cfn-bootstrap cloud-init-per instance custom_docker_options cat <<'EOF' > /etc/sysconfig/docker DAEMON_MAXFILES=1048576 DAEMON_PIDFILE_TIMEOUT=10 OPTIONS=\"--default-ulimit nofile=1024:4096\" EOF cloud-init-per instance custom_docker_storage_options cat <<'EOF' > /etc/sysconfig/docker-storage-setup DEVS=\"${InstanceStoreDevices}\" STORAGE_DRIVER=\"devicemapper\" VG=docker DATA_SIZE=99%FREE AUTO_EXTEND_POOL=yes LV_ERROR_WHEN_FULL=yes EXTRA_DOCKER_STORAGE_OPTIONS=\"--storage-opt dm.fs=ext4 --storage-opt dm.use_deferred_deletion=true --storage-opt dm.basesize=20G\" EOF cloud-init-per instance custom_ecs_options cat <<'EOF' > ", "keywords": ["instance", "storage", "billing mode"]}]}], "answers": [{"Id": "58403427", "PostTypeId": "2", "ParentId": "58317315", "CreationDate": "2019-10-15T22:34:31.323", "Score": "0", "Body": "<p>An ASG is just a convenient way to spin up identical instances using the specified launch configurations.</p>\n\n<p>If you grab the launch configurations and use that to spin up instances, you essentially cut out the ASG.</p>\n\n<p>At the end of the day, you want to set your user data to register your container instance to your cluster.</p>\n\n<p><a href=\"https://i.stack.imgur.com/7Pi1U.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/7Pi1U.png\" alt=\"user_data ec2 launch\"></a></p>\n\n<p>See <a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_container_instance.html\" rel=\"nofollow noreferrer\">https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_container_instance.html</a></p>\n\n<p>With that, you can create a <a href=\"https://aws.amazon.com/about-aws/whats-new/2017/11/introducing-launch-templates-for-amazon-ec2-instances/\" rel=\"nofollow noreferrer\">launch template</a> and use that to spin up more instances using your dedicated host. You can then build a poor man's ASG using Cloudwatch and Lambda.</p>\n", "OwnerUserId": "1361802", "LastActivityDate": "2019-10-15T22:34:31.323", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "207310960", "PostHistoryTypeId": "2", "PostId": "58403427", "RevisionGUID": "49bf7afc-f37e-4a7b-8ca9-27bb5a8633fd", "CreationDate": "2019-10-15T22:34:31.323", "UserId": "1361802", "Text": "An ASG is just a convenient way to spin up identical instances using the specified launch configurations.\r\n\r\nIf you grab the launch configurations and use that to spin up instances, you essentially cut out the ASG.\r\n\r\nAt the end of the day, you want to set your user data to register your container instance to your cluster.\r\n\r\n[![user_data ec2 launch][1]][1]\r\n\r\nSee https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_container_instance.html\r\n\r\nWith that, you can create a [launch template](https://aws.amazon.com/about-aws/whats-new/2017/11/introducing-launch-templates-for-amazon-ec2-instances/) and use that to spin up more instances using your dedicated host. You can then build a poor man's ASG using Cloudwatch and Lambda.\r\n\r\n  [1]: https://i.stack.imgur.com/7Pi1U.png", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "At the end of the day, you want to set your user data to register your container instance to your cluster. ", "keywords": ["instance", "cluster"]}]}], "filtered-sentences": [{"source": "Body", "text": "At the end of the day, you want to set your user data to register your container instance to your cluster. ", "keywords": ["instance", "cluster"]}]}], "contains-topic": true, "filtered-sentences": [{"source": "Title", "text": "ECS cluster without Autoscaling", "keywords": ["cluster"]}, {"source": "Body", "text": "I have a requirement of creating an ECS Cluster without using autoscaling. ", "keywords": ["cluster"]}, {"source": "Body", "text": "DH is mainly for cost savings and for some cases because of the savings is worth doing even if we can't use ASGs. ", "keywords": ["cost"]}, {"source": "Body", "text": "I understand this can be done using Macros and Custom Resources backed up with Lambda or using Troposphere to loop over the instance. ", "keywords": ["instance"]}]}
{"Id": "59662283", "PostTypeId": "1", "AcceptedAnswerId": "60067235", "CreationDate": "2020-01-09T10:50:00.327", "Score": "9", "ViewCount": "9490", "Body": "<p>In the following (abbreviated CloudFormation template), I am trying to configure an AWS Lambda function to get a value from AWS Secrets Manager injected into its environment:</p>\n\n<pre><code>Resources:\n  Function:\n    Type: AWS::Serverless::Function\n    Properties:\n      Environment:\n        Variables:\n          SECRET_KEY: !Sub '{{resolve:secretsmanager:${Secret}:SecretString:KEY}}'\n\n  Secret:\n    Type: AWS::SecretsManager::Secret\n    Properties:\n      Name: 'very-secret-thing'\n      SecretString: '{\"KEY\":\"dummy\"}'\n</code></pre>\n\n<p>When creating a stack using this template, everything comes up as expected. I then go and change the value of the secret outside of CloudFormation, as I would not really want the secret checked into source control. This is totally possible, and the <a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-secretsmanager-secret.html#cfn-secretsmanager-secret-secretstring\" rel=\"noreferrer\">documentation</a> implies, that the secret's value will not be touched subsequent CloudFormation stack updates, as long as I avoid changing the dummy value for <code>SecretString</code> in the template.</p>\n\n<p>So, after setting the actual secret in the AWS Console, I need to trigger a redeploy of the Lambda function, so that the new secret value will be resolved by CloudFormation and set in the function's environment. How do I do that?</p>\n\n<p>Executing <code>aws cloudformation deploy</code> fails with the message: <em>No changes to deploy.</em></p>\n\n<p>I suspect CloudFormation is comparing the \"raw\" version of the template with what was deployed last, without first resolving the references to Secrets Manager. Is that the case? And is there some trick to force earlier dereferencing?</p>\n\n<p><sub><em>Footnote: I am well aware that using Secrets Manager this way will cause the secret value to be visible in the AWS Lambda Console, and that getting the value from Secrets Manager at runtime would be the more secure approach. That just happens to be out-of-scope for what I am hoping to do.</em></sub></p>\n", "OwnerUserId": "121364", "LastActivityDate": "2023-02-16T14:45:25.537", "Title": "Can I force CloudFormation to resolve values from Secrets Manager?", "Tags": "|amazon-web-services|aws-cloudformation|aws-secrets-manager|", "AnswerCount": "3", "CommentCount": "1", "FavoriteCount": "0", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "105491481", "PostId": "59662283", "Score": "1", "Text": "When Cloudformation references secure values such as secrets manager or ssm, it is referencing the `literal dynamic reference string` [source](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/dynamic-references.html). I have had similar issues with lambda not updating in the past. The easiest way is just to update your code uri to force an update, but that's not ideal. Another thing to look at would be [lambda versioning](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html), but it too has many issues when forcing an update with no code change.", "CreationDate": "2020-01-09T14:38:23.557", "UserId": "10963381", "filtered-sentences": [{"source": "Text", "text": "Another thing to look at would be [lambda versioning](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html), but it too has many issues when forcing an update with no code change.", "keywords": ["change"]}]}], "history": [{"Id": "212614089", "PostHistoryTypeId": "2", "PostId": "59662283", "RevisionGUID": "b9910c6f-1869-4c64-80fe-7537ec536f55", "CreationDate": "2020-01-09T10:50:00.327", "UserId": "121364", "Text": "In the following (abbreviated CloudFormation template), I am trying to configure an AWS Lambda function to get a value from AWS Secrets Manager injected into its environment:\r\n\r\n    Resources:\r\n      Function:\r\n        Type: AWS::Serverless::Function\r\n        Properties:\r\n          Environment:\r\n            Variables:\r\n              SECRET_KEY: !Sub '{{resolve:secretsmanager:${Secret}:SecretString:KEY}}'\r\n    \r\n      Secret:\r\n        Type: AWS::SecretsManager::Secret\r\n        Properties:\r\n          Name: 'very-secret-thing'\r\n          SecretString: '{\"KEY\":\"dummy\"}'\r\n\r\nWhen creating a stack using this template, everything comes up as expected. I then go and change the value of the secret outside of CloudFormation, as I would not really want the secret checked into source control. This is totally possible, and the [documentation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-secretsmanager-secret.html#cfn-secretsmanager-secret-secretstring) implies, that the secret's value will not be touched subsequent CloudFormation stack updates, as long as I avoid changing the dummy value for `SecretString` in the template.\r\n\r\nSo, after setting the actual secret in the AWS Console, I need to trigger a redeploy of the Lambda function, so that the new secret value will be resolved by CloudFormation and set in the function's environment. How do I do that?\r\n\r\nExecuting `aws cloudformation deploy` fails with the message: _No changes to deploy._\r\n\r\nI suspect CloudFormation is comparing the \"raw\" version of the template with what was deployed last, without first resolving the references to Secrets Manager. Is that the case? And is there some trick to force earlier dereferencing?\r\n\r\n<sub><em>Footnote: I am well aware that using Secrets Manager this way will cause the secret value to be visible in the AWS Lambda Console, and that getting the value from Secrets Manager at runtime would be the more secure approach. That just happens to be out-of-scope for what I am hoping to do.</em></sub>", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "I then go and change the value of the secret outside of CloudFormation, as I would not really want the secret checked into source control. ", "keywords": ["change"]}, {"source": "Text", "text": "This is totally possible, and the [documentation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-secretsmanager-secret.html#cfn-secretsmanager-secret-secretstring) implies, that the secret's value will not be touched subsequent CloudFormation stack updates, as long as I avoid changing the dummy value for `SecretString` in the template. ", "keywords": ["change"]}, {"source": "Text", "text": "Executing `aws cloudformation deploy` fails with the message: _No changes to deploy._ ", "keywords": ["change"]}]}, {"Id": "212614090", "PostHistoryTypeId": "1", "PostId": "59662283", "RevisionGUID": "b9910c6f-1869-4c64-80fe-7537ec536f55", "CreationDate": "2020-01-09T10:50:00.327", "UserId": "121364", "Text": "Can I force CloudFormation to resolve values from Secrets Manager?", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}, {"Id": "212614091", "PostHistoryTypeId": "3", "PostId": "59662283", "RevisionGUID": "b9910c6f-1869-4c64-80fe-7537ec536f55", "CreationDate": "2020-01-09T10:50:00.327", "UserId": "121364", "Text": "|amazon-web-services|aws-cloudformation|aws-secrets-manager|", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "answers": [{"Id": "60067235", "PostTypeId": "2", "ParentId": "59662283", "CreationDate": "2020-02-04T23:59:51.570", "Score": "16", "Body": "<p>You can artificially change <em>something else</em> on the <code>AWS::Serverless::Function</code> resource to force it to update when you do your deployment.</p>\n\n<p>Say, for example, a timestamp:</p>\n\n<pre><code>Parameters:\n  DeployTimestamp: { Type: String }\n\nResources:\n  Function:\n    Type: AWS::Serverless::Function\n    Properties:\n      Environment:\n        Variables:\n          SECRET_KEY: !Sub '{{resolve:secretsmanager:${Secret}:SecretString:KEY}}'\n          SECRET_KEY_UPDATED: !Ref DeployTimestamp\n</code></pre>\n\n<p>Assuming you do your deployment from a script, then you'd do something like <code>aws cloudformation deploy --parameter-overrides \"DeployTimestamp=$(date)\"</code> to change the value each time.</p>\n\n<p>The downside to this, of course, is that the function will update every deployment, even if the secret hasn't updated. If that bothers you, you could get fancier and inject <code>aws secretsmanager describe-secret --query LastChangedDate</code> as a parameter instead of the current time.</p>\n", "OwnerUserId": "2530463", "LastActivityDate": "2020-02-04T23:59:51.570", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "214317251", "PostHistoryTypeId": "2", "PostId": "60067235", "RevisionGUID": "46b550ab-37cd-456d-8164-b740d48cab78", "CreationDate": "2020-02-04T23:59:51.570", "UserId": "2530463", "Text": "You can artificially change *something else* on the `AWS::Serverless::Function` resource to force it to update when you do your deployment.\r\n\r\nSay, for example, a timestamp:\r\n```\r\nParameters:\r\n  DeployTimestamp: { Type: String }\r\n\r\nResources:\r\n  Function:\r\n    Type: AWS::Serverless::Function\r\n    Properties:\r\n      Environment:\r\n        Variables:\r\n          SECRET_KEY: !Sub '{{resolve:secretsmanager:${Secret}:SecretString:KEY}}'\r\n          SECRET_KEY_UPDATED: !Ref DeployTimestamp\r\n```\r\n\r\nAssuming you do your deployment from a script, then you'd do something like `aws cloudformation deploy --parameter-overrides \"DeployTimestamp=$(date)\"` to change the value each time.\r\n\r\nThe downside to this, of course, is that the function will update every deployment, even if the secret hasn't updated. If that bothers you, you could get fancier and inject `aws secretsmanager describe-secret --query LastChangedDate` as a parameter instead of the current time.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": [{"source": "Text", "text": "You can artificially change *something else* on the `AWS::Serverless::Function` resource to force it to update when you do your deployment. ", "keywords": ["change"]}, {"source": "Text", "text": "Assuming you do your deployment from a script, then you'd do something like `aws cloudformation deploy --parameter-overrides \"DeployTimestamp=$(date)\"` to change the value each time. ", "keywords": ["change"]}]}], "filtered-sentences": [{"source": "Body", "text": "You can artificially change something else on the AWS::Serverless::Function resource to force it to update when you do your deployment. ", "keywords": ["change"]}, {"source": "Body", "text": "Say, for example, a timestamp: Assuming you do your deployment from a script, then you'd do something like aws cloudformation deploy --parameter-overrides \"DeployTimestamp=$(date)\" to change the value each time. ", "keywords": ["change"]}]}, {"Id": "59670517", "PostTypeId": "2", "ParentId": "59662283", "CreationDate": "2020-01-09T18:59:40.043", "Score": "0", "Body": "<p>You say that reading the value in the Lambda is out of scope, but that is really the correct solution. It not only improves security, but allows the Lambda to pickup the latest value when the secret is rotated.</p>\n\n<p>If you read the secret outside the handler (that is to say, during initialization), the number of reads is minimized. If this is a java lambda connecting to a database, you could also use the <a href=\"https://github.com/aws/aws-secretsmanager-jdbc\" rel=\"nofollow noreferrer\">secrets manager jdbc wrapper</a> which will automatically fetch the secret.</p>\n", "OwnerUserId": "5844292", "LastActivityDate": "2020-01-09T18:59:40.043", "CommentCount": "5", "ContentLicense": "CC BY-SA 4.0", "comments": [{"Id": "105522613", "PostId": "59670517", "Score": "4", "Text": "A bit of background: I am looking at hundreds of existing Lambda functions, that all get their secrets (which are generally only semi-sensitive) through the environment. I wish to import these functions into CloudFormation, and for this task, retrofitting each function to fetch secrets from Secrets Manager at run-time would be a significant scope-creep. I hope this helps explain why.", "CreationDate": "2020-01-10T13:42:30.147", "UserId": "121364", "filtered-sentences": []}, {"Id": "116112059", "PostId": "59670517", "Score": "2", "Text": "There is also a cost with reading secret values.   Referencing the value in the template as an environment variable minimizes that cost.   I do wish there was a way to force redeploy of a CloudFormation template even if the template itself has no changes.", "CreationDate": "2021-01-11T18:13:41.260", "UserId": "107683", "filtered-sentences": [{"source": "Text", "text": "There is also a cost with reading secret values. ", "keywords": ["cost"]}, {"source": "Text", "text": "Referencing the value in the template as an environment variable minimizes that cost. ", "keywords": ["cost"]}, {"source": "Text", "text": "I do wish there was a way to force redeploy of a CloudFormation template even if the template itself has no changes.", "keywords": ["change"]}]}, {"Id": "126060878", "PostId": "59670517", "Score": "0", "Text": "There's also API rate limits to consider, if you have particularly busy Lambda functions.", "CreationDate": "2022-03-02T04:24:27.607", "UserId": "1982136", "filtered-sentences": []}, {"Id": "128647282", "PostId": "59670517", "Score": "0", "Text": "In the case of Secrets Manager,  [high API call rates](https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_limits.html) are supported. Also, by following [Lambda best practices](https://docs.aws.amazon.com/lambda/latest/dg/best-practices.html) the GetSecretValue call can be limited to just Lambda coldstart instead of every Lambda call. That is to say, by fetching the secret during outside the handler, the number of calls are drastically reduced.", "CreationDate": "2022-07-01T21:57:11.810", "UserId": "5844292", "filtered-sentences": []}, {"Id": "135686729", "PostId": "59670517", "Score": "0", "Text": "There is also a [Lambda extension](https://docs.aws.amazon.com/secretsmanager/latest/userguide/retrieving-secrets_lambda.html) that caches secrets to reduce calls to SM.", "CreationDate": "2023-08-24T13:30:30.607", "UserId": "5645292", "filtered-sentences": []}], "history": [{"Id": "212647717", "PostHistoryTypeId": "2", "PostId": "59670517", "RevisionGUID": "d6d92a69-1bea-4c20-bf91-dd098c38dd06", "CreationDate": "2020-01-09T18:59:40.043", "UserId": "5844292", "Text": "You say that reading the value in the Lambda is out of scope, but that is really the correct solution. It not only improves security, but allows the Lambda to pickup the latest value when the secret is rotated.\r\n\r\nIf you read the secret outside the handler (that is to say, during initialization), the number of reads is minimized. If this is a java lambda connecting to a database, you could also use the [secrets manager jdbc wrapper](https://github.com/aws/aws-secretsmanager-jdbc) which will automatically fetch the secret.", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "filtered-sentences": []}, {"Id": "75473899", "PostTypeId": "2", "ParentId": "59662283", "CreationDate": "2023-02-16T14:45:25.537", "Score": "3", "Body": "<p>Just to add for other readers who find this page, <a href=\"https://aws.amazon.com/premiumsupport/knowledge-center/cloudformation-stack-update-secrets/\" rel=\"nofollow noreferrer\">AWS published</a> a solution to reference the version ID of the secret at the end of the key.</p>\n<pre><code>Resources:\n    SG:\n        Type: AWS::EC2::SecurityGroup\n        Properties:\n            GroupDescription: '{{resolve:secretsmanager:mysecret:SecretString:MyKey::ab01234c-5d67-89ef-01gh-2ijk345l6m78}}'\n            SecurityGroupIngress:\n                  - IpProtocol: tcp\n                    FromPort: 8080\n                    ToPort: 8080\n                    CidrIp: 0.0.0.0/0\n</code></pre>\n<p>Now the thing is, you'll apparently have to do an API call to figure out what the versionId is since it's not on the console (which doesn't make any sense but it's AWS...).</p>\n", "OwnerUserId": "4078511", "LastActivityDate": "2023-02-16T14:45:25.537", "CommentCount": "0", "ContentLicense": "CC BY-SA 4.0", "history": [{"Id": "288191928", "PostHistoryTypeId": "2", "PostId": "75473899", "RevisionGUID": "4b113762-9e82-40c7-b810-01d2ea66d7b9", "CreationDate": "2023-02-16T14:45:25.537", "UserId": "4078511", "Text": "Just to add for other readers who find this page, [AWS published][1] a solution to reference the version ID of the secret at the end of the key.\r\n\r\n    Resources:\r\n        SG:\r\n            Type: AWS::EC2::SecurityGroup\r\n            Properties:\r\n                GroupDescription: '{{resolve:secretsmanager:mysecret:SecretString:MyKey::ab01234c-5d67-89ef-01gh-2ijk345l6m78}}'\r\n                SecurityGroupIngress:\r\n                      - IpProtocol: tcp\r\n                        FromPort: 8080\r\n                        ToPort: 8080\r\n                        CidrIp: 0.0.0.0/0\r\n\r\n\r\nNow the thing is, you'll apparently have to do an API call to figure out what the versionId is since it's not on the console (which doesn't make any sense but it's AWS...).\r\n\r\n  [1]: https://aws.amazon.com/premiumsupport/knowledge-center/cloudformation-stack-update-secrets/", "ContentLicense": "CC BY-SA 4.0", "filtered-sentences": []}], "filtered-sentences": []}], "contains-topic": true, "filtered-sentences": [{"source": "Body", "text": "I then go and change the value of the secret outside of CloudFormation, as I would not really want the secret checked into source control. ", "keywords": ["change"]}, {"source": "Body", "text": "This is totally possible, and the documentation implies, that the secret's value will not be touched subsequent CloudFormation stack updates, as long as I avoid changing the dummy value for SecretString in the template. ", "keywords": ["change"]}, {"source": "Body", "text": "Executing aws cloudformation deploy fails with the message: No changes to deploy. ", "keywords": ["change"]}]}